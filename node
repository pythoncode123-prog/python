import React, { useState, useEffect, useMemo } from 'react';
import { useQuery } from 'react-query';
import { decommQueries } from '../queries'; 

export function DataTable<TData, TVal>({
  caption,
  columns,
  display,
  enableRowSelection = false,
  onRowSelectionChange,
  ...rest
}: DataTableProps<TData, TVal>) {
  const [filteredData, setFilteredData] = useState<any[]>([]);
  
  // ✅ ADDED: State for column filters
  const [columnFilters, setColumnFilters] = useState<{ [key: string]: string }>({});
  const [debouncedFilters, setDebouncedFilters] = useState(columnFilters);
  
  const [pagination, setPagination] = useState({
    pageIndex: 0,
    pageSize: 10
  });
  const [sorting, setSorting] = useState({});
  
  // ✅ ADDED: Debounce filters to prevent excessive API calls
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedFilters(columnFilters);
    }, 300);
    
    return () => {
      clearTimeout(handler);
    };
  }, [columnFilters]);
  
  // ✅ MODIFIED: Added debouncedFilters to query dependencies
  const {
    data,
    isLoading,
    isError,
    error,
    refetch
  } = useQuery(
    ['serverDetails', pagination, sorting, debouncedFilters], // Added filters to query key
    () => decommQueries.serverDetails.list({
      pagination: pagination,
      sorting: sorting,
      filters: debouncedFilters // Pass filters to query
    })(),
    {
      keepPreviousData: true,
      refetchOnWindowFocus: false,
      onSuccess: (data) => {
        setFilteredData(data || []);
      }
    }
  );
  
  // Get column IDs from columns object
  const columnIds = useMemo(() => {
    return Object.keys(columns || {});
  }, [columns]);
  
  // ✅ ADDED: Update a specific column filter
  const handleFilterChange = (columnId: string, value: string) => {
    setColumnFilters(prev => ({
      ...prev,
      [columnId]: value
    }));
  };
  
  // ✅ ADDED: Clear all filters
  const clearAllFilters = () => {
    setColumnFilters({});
  };
  
  // ✅ ADDED: Extract unique values for filter options
  const getOptionsForColumn = (columnId: string) => {
    if (!filteredData) return [];
    
    const uniqueValues = new Set();
    filteredData.forEach(item => {
      if (item[columnId] !== undefined && item[columnId] !== null) {
        uniqueValues.add(item[columnId]);
      }
    });
    
    return Array.from(uniqueValues).map(value => ({
      label: String(value),
      value: String(value)
    }));
  };
  
  const handlePageChange = (newPageIndex: number) => {
    setPagination(prev => ({
      ...prev,
      pageIndex: newPageIndex
    }));
  };
  
  // ✅ ADDED: Render filter row above the table
  const renderFilters = () => (
    <div className="data-table-filters">
      <div className="filters-header">
        <h4>Filters</h4>
        <button 
          className="clear-filters-btn" 
          onClick={clearAllFilters}
          disabled={Object.keys(columnFilters).length === 0}
        >
          Clear All
        </button>
      </div>
      <div className="filter-row">
        {columnIds.map(columnId => (
          <div key={columnId} className="filter-item">
            <SearchableCombobox
              options={getOptionsForColumn(columnId)}
              value={columnFilters[columnId] || ''}
              onChange={(e) => handleFilterChange(columnId, e.target.value)}
              placeholder={`Filter ${columns[columnId]?.label || columnId}`}
            />
          </div>
        ))}
      </div>
    </div>
  );
  
  // ✅ ADDED: SearchableCombobox component for filter inputs
  function SearchableCombobox({
    options,
    value,
    onChange,
    placeholder = "Search or select..."
  }) {
    const [searchTerm, setSearchTerm] = useState(value || "");
    const [isOpen, setIsOpen] = useState(false);
    const dropdownRef = React.useRef<HTMLDivElement>(null);
  
    // Close dropdown when clicking outside
    useEffect(() => {
      const handleClickOutside = (event: MouseEvent) => {
        if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
          setIsOpen(false);
        }
      };
      
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);
  
    // Update search term when value changes
    useEffect(() => {
      setSearchTerm(value || "");
    }, [value]);
  
    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      setSearchTerm(e.target.value);
      setIsOpen(true);
      onChange(e);
    };
  
    const handleSelect = (option: { value: string, label: string }) => {
      setSearchTerm(option.label);
      setIsOpen(false);
      const fakeEvent = { 
        target: { value: option.value },
        currentTarget: { value: option.value }
      };
      onChange(fakeEvent as any);
    };
  
    // Filter options based on search term
    const filteredOptions = options.filter(option => 
      option.label.toLowerCase().includes(searchTerm.toLowerCase())
    );
  
    return (
      <div className="searchable-combobox" ref={dropdownRef}>
        <input
          type="text"
          value={searchTerm}
          onChange={handleInputChange}
          onFocus={() => setIsOpen(true)}
          placeholder={placeholder}
          className="combobox-input"
        />
        {isOpen && filteredOptions.length > 0 && (
          <div className="combobox-dropdown">
            {filteredOptions.map((option, index) => (
              <div
                key={index}
                className="combobox-option"
                onClick={() => handleSelect(option)}
              >
                {option.label}
              </div>
            ))}
          </div>
        )}
      </div>
    );
  }
  
  return (
    <div className="data-table-container">
      {caption && <div className="data-table-caption">{caption}</div>}
      
      {/* ✅ ADDED: Render filters */}
      {renderFilters()}
      
      <table className="data-table">
        <thead>
          <tr>
            {columnIds.map(colId => (
              <th key={colId}>
                {columns[colId]?.label || colId}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {isLoading ? (
            <tr>
              <td colSpan={columnIds.length} className="loading-cell">
                Loading data...
              </td>
            </tr>
          ) : isError ? (
            <tr>
              <td colSpan={columnIds.length} className="error-cell">
                Error loading data: {error instanceof Error ? error.message : 'Unknown error'}
              </td>
            </tr>
          ) : filteredData.length === 0 ? (
            <tr>
              <td colSpan={columnIds.length} className="no-data-cell">
                No data available
              </td>
            </tr>
          ) : (
            filteredData.map((row, index) => (
              <tr 
                key={index}
                className={enableRowSelection ? "selectable-row" : ""}
                onClick={enableRowSelection ? () => onRowSelectionChange?.(row) : undefined}
              >
                {columnIds.map(colId => (
                  <td key={colId}>{row[colId]}</td>
                ))}
              </tr>
            ))
          )}
        </tbody>
      </table>
      
      {/* Pagination controls */}
      <div className="pagination-controls">
        <button 
          onClick={() => handlePageChange(pagination.pageIndex - 1)}
          disabled={pagination.pageIndex === 0 || isLoading}
        >
          Previous
        </button>
        <span>Page {pagination.pageIndex + 1}</span>
        <button 
          onClick={() => handlePageChange(pagination.pageIndex + 1)}
          disabled={!filteredData || filteredData.length < pagination.pageSize || isLoading}
        >
          Next
        </button>
      </div>
    </div>
  );
}
