#!/usr/bin/env python3
import os
import sys
import getpass
import configparser
from cryptography.fernet import Fernet

# Current time and user from your message
TIMESTAMP = "2025-08-24 15:06:46"
USERNAME = "satish537"

print(f"\n===== Database Password Fix =====")
print(f"Time: {TIMESTAMP}")
print(f"User: {USERNAME}")

# Get the base directory (where this script is located)
base_dir = os.path.dirname(os.path.abspath(__file__))
print(f"Working directory: {base_dir}")

# Key file location
key_file = os.path.join(base_dir, "secure.key")
print(f"Key file location: {key_file}")

# Function to generate a new key
def generate_key():
    print("Generating new encryption key...")
    key = Fernet.generate_key()
    with open(key_file, "wb") as f:
        f.write(key)
    print(f"New key written to {key_file}")
    return key

# Get or generate key
if os.path.exists(key_file):
    print("Reading existing key...")
    with open(key_file, "rb") as f:
        key = f.read()
    print(f"Key loaded: {len(key)} bytes")
else:
    key = generate_key()

# Create Fernet cipher
cipher = Fernet(key)

# Find all INI files
config_dir = os.path.join(base_dir, "config")
ini_files = [os.path.join(config_dir, f) for f in os.listdir(config_dir) 
             if f.endswith('.ini') and os.path.isfile(os.path.join(config_dir, f))]

print(f"\nFound {len(ini_files)} INI files: {', '.join(os.path.basename(f) for f in ini_files)}")

# Process each INI file
for ini_file in ini_files:
    print(f"\nProcessing {os.path.basename(ini_file)}:")
    
    # Read the INI file
    config = configparser.ConfigParser()
    config.read(ini_file)
    
    if 'DATABASE' not in config:
        print("- No DATABASE section found, skipping.")
        continue
    
    # Get username and password
    if 'Username' not in config['DATABASE']:
        print("- No Username field found, skipping.")
        continue
        
    username = config['DATABASE']['Username']
    
    if 'Password' not in config['DATABASE']:
        print("- No Password field found, skipping.")
        continue
        
    password = config['DATABASE']['Password']
    print(f"- Username: {username}")
    print(f"- Password found: {'*' * len(password)}")
    
    # Encrypt the password
    encrypted = cipher.encrypt(password.encode())
    encrypted_str = encrypted.decode()
    print(f"- Encrypted password (first 20 chars): {encrypted_str[:20]}...")
    
    # Update the config
    config['DATABASE']['Password_Encrypted'] = encrypted_str
    
    # Write the updated config back to the file
    with open(ini_file, 'w') as f:
        config.write(f)
    
    print(f"- Updated {ini_file} with new encrypted password.")
    
    # Test decryption
    try:
        decrypted = cipher.decrypt(encrypted).decode()
        if decrypted == password:
            print("- ✅ Encryption/decryption test successful!")
        else:
            print(f"- ❌ Decryption test failed! Original: {password}, Decrypted: {decrypted}")
    except Exception as e:
        print(f"- ❌ Decryption test error: {e}")

print("\n===== Creating Decrypt Test Tool =====")

# Create a simple decrypt test tool
decrypt_test = """#!/usr/bin/env python3
import os
import sys
from cryptography.fernet import Fernet

# Get key file path
key_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "secure.key")

if not os.path.exists(key_file):
    print(f"Key file not found: {key_file}")
    sys.exit(1)
    
# Load key
with open(key_file, "rb") as f:
    key = f.read()
    
print(f"Loaded key: {len(key)} bytes")

# Create cipher
cipher = Fernet(key)

# Get encrypted password from command line
if len(sys.argv) < 2:
    print("Usage: python decrypt_test.py <encrypted_password>")
    sys.exit(1)

encrypted = sys.argv[1]
print(f"Encrypted password: {encrypted[:20]}...")

try:
    # Decrypt the password
    decrypted = cipher.decrypt(encrypted.encode()).decode()
    print(f"Decrypted password: {decrypted}")
except Exception as e:
    print(f"Decryption error: {e}")
"""

with open(os.path.join(base_dir, "decrypt_test.py"), "w") as f:
    f.write(decrypt_test)
print("Created decrypt_test.py tool")

print("\n===== Updating db_utils.py =====")

# Simple db_utils modification that will work
db_utils_path = os.path.join(base_dir, "lib", "db_utils.py")
db_utils_backup = db_utils_path + ".bak"

# Backup original
if os.path.exists(db_utils_path):
    with open(db_utils_path, "r") as src:
        with open(db_utils_backup, "w") as dst:
            dst.write(src.read())
    print(f"Backed up original db_utils.py to {db_utils_backup}")

# Create a modified version with direct Fernet usage
db_utils_content = """
import pyodbc
import csv
import configparser
import logging
from datetime import datetime
import os
import oracledb
from cryptography.fernet import Fernet

def load_config(config_path):
    """Load database configuration from file."""
    logging.info(f"Loading database config from {config_path}")
    
    config = configparser.ConfigParser()
    config.read(config_path)
    
    if 'DATABASE' not in config:
        logging.error(f"No [DATABASE] section found in {config_path}")
        return None
        
    db_config = config['DATABASE']
    
    # Get username for logging
    username = db_config.get('Username', 'unknown')
    
    # Get password (plain text first)
    password = db_config.get('Password', '')
    
    # Try to decrypt password if available
    if 'Password_Encrypted' in db_config:
        try:
            # Get key file path
            key_file = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "secure.key")
            
            if os.path.exists(key_file):
                # Load key
                with open(key_file, "rb") as f:
                    key = f.read()
                
                # Create cipher
                cipher = Fernet(key)
                
                # Decrypt password
                encrypted = db_config['Password_Encrypted'].encode()
                password = cipher.decrypt(encrypted).decode()
                logging.info(f"Using decrypted password for {username}")
            else:
                logging.error(f"Key file not found: {key_file}")
        except Exception as e:
            logging.error(f"Error decrypting password: {str(e)}")
    
    # Build config dictionary
    db_params = {
        'host': db_config.get('DBHost', ''),
        'port': db_config.get('Port', '1521'),
        'service': db_config.get('ServiceName', ''),
        'schema': db_config.get('SchemaName', ''),
        'user': username,
        'password': password
    }
    
    # Log connection params (except password)
    logging.info(f"DB connection parameters:")
    logging.info(f"  Host: {db_params['host']}")
    logging.info(f"  Port: {db_params['port']}")
    logging.info(f"  Service: {db_params['service']}")
    logging.info(f"  User: {db_params['user']}")
    
    return db_params

def connect_oracle(cfg):
    """Connect to Oracle database using configuration."""
    if not cfg:
        logging.error("Invalid database configuration")
        return None
        
    try:
        dsn = oracledb.makedsn(
            cfg['host'],
            int(cfg['port']),
            service_name=cfg['service']
        )
        
        logging.info(f"Connecting to Oracle as {cfg['user']}")
        conn = oracledb.connect(
            user=cfg['user'],
            password=cfg['password'],
            dsn=dsn
        )
        logging.info("Database connection successful")
        return conn
    except oracledb.DatabaseError as e:
        error_obj = e.args[0]
        if hasattr(error_obj, 'code'):
            logging.error(f"Oracle Error {error_obj.code}: {error_obj.message}")
        else:
            logging.error(f"Oracle Error: {str(e)}")
        return None
    except Exception as e:
        logging.error(f"Error connecting to database: {str(e)}")
        return None

def execute_query_and_write_csv(conn, query, csv_path):
    """Execute query and write results to CSV file."""
    cursor = conn.cursor()
    try:
        # Split the query on ';' and remove empty statements
        statements = [stmt.strip() for stmt in query.split(';') if stmt.strip()]
        # Execute all but the last statement (setup statements)
        for stmt in statements[:-1]:
            cursor.execute(stmt)
        # Execute the last statement (the SELECT)
        cursor.execute(statements[-1])
        columns = [column[0] for column in cursor.description]
        with open(csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(columns)
            row_count = 0
            for row in cursor:
                writer.writerow(row)
                row_count += 1
        logging.info(f"Wrote {row_count} rows to {csv_path}")
        return True
    except Exception as e:
        logging.error(f"Error executing query: {str(e)}")
        return False
    finally:
        if cursor:
            cursor.close()

def sql_to_csv(config_file, query_file, output_csv, execution_timestamp=None):
    """Execute SQL and export to CSV."""
    logging.info("Starting SQL to CSV process")
    try:
        # Check query file exists
        if not os.path.exists(query_file):
            logging.error(f"Query file '{query_file}' not found")
            return False

        cfg = load_config(config_file)
        if not cfg:
            return False

        with open(query_file, 'r', encoding='utf-8') as f:
            query = f.read()
            
        if '<EM_schema>' in query:
            query = query.replace('<EM_schema>', cfg['schema'])
            logging.info(f"Replaced schema placeholder with: {cfg['schema']}")
        
        conn = connect_oracle(cfg)
        if not conn:
            logging.error("Failed to connect to database")
            return False
            
        try:
            result = execute_query_and_write_csv(conn, query, output_csv)
            conn.close()
            
            if result:
                logging.info("SQL to CSV process completed successfully")
                return True
            else:
                logging.error("SQL to CSV process failed")
                return False
        except Exception as e:
            logging.error(f"Error in SQL execution: {str(e)}")
            conn.close()
            return False
    except Exception as e:
        logging.error(f"Error in SQL to CSV process: {str(e)}")
        return False
"""

with open(db_utils_path, "w") as f:
    f.write(db_utils_content)
print(f"Updated {db_utils_path} with direct Fernet implementation")

print("\n===== Next Steps =====")
print("1. The fix has been applied to all INI files")
print("2. db_utils.py has been updated with a direct decryption implementation")
print("3. A decrypt_test.py tool has been created to help test passwords")

print("\nTo test a specific encrypted password:")
print("python decrypt_test.py \"your-encrypted-password-here\"")

print("\nNow try running your main script again!")
