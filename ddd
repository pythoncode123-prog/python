import csv
import configparser
import logging
from datetime import datetime
import os
import pyodbc  # Keep this for SQL Server connections

def load_config(config_path):
    """Load database configuration from file."""
    config = configparser.ConfigParser()
    config.read(config_path)
    db_config = config['DATABASE']
    return {
        'host': db_config['DBHost'],
        'port': db_config['Port'],
        'service': db_config['ServiceName'],
        'schema': db_config['SchemaName'],
        'user': db_config['Username'],
        'password': db_config['Password'],
        'db_type': db_config.get('DBType', 'SQLSERVER')
    }

def connect_sql_server(cfg):
    """Connect to SQL server using configuration."""
    conn_str = (
        f"DRIVER={{ODBC Driver 17 for SQL Server}};"
        f"SERVER={cfg['host']},{cfg['port']};"
        f"DATABASE={cfg['service']};"
        f"UID={cfg['user']};"
        f"PWD={cfg['password']}"
    )
    return pyodbc.connect(conn_str)

def create_oracle_dummy_csv(query, output_csv, cfg):
    """
    Create a dummy CSV file with appropriate headers
    since we can't connect to Oracle directly.
    """
    logging.info(f"Creating sample CSV output based on query structure")
    
    try:
        # Parse the SQL query to guess column names
        # This is a simplified approach - might need adjustment based on your actual queries
        query_upper = query.upper()
        if "SELECT" in query_upper:
            # Try to extract column names from the SELECT statement
            select_part = query_upper.split("FROM")[0].replace("SELECT", "").strip()
            columns = [col.strip().split(' ')[-1] for col in select_part.split(',')]
            
            # Clean up any aliases
            columns = [col.split('.')[-1].split(' AS ')[-1].strip('"').strip("'") for col in columns]
        else:
            # Fallback to default columns
            columns = ["COLUMN1", "COLUMN2", "COLUMN3"]
        
        # Create the CSV with headers but no data
        with open(output_csv, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(columns)
            
            # Add a note in the CSV that this is a dummy file
            writer.writerow(["NOTE: This is a sample CSV. Please run the following query in SQL Developer:"])
            # Write the query as multiple rows for readability
            query_lines = query.split('\n')
            for line in query_lines:
                writer.writerow([line])
            
            # Add connection information for reference
            writer.writerow([])
            writer.writerow(["Connection Information:"])
            writer.writerow([f"Host: {cfg['host']}"])
            writer.writerow([f"Port: {cfg['port']}"])
            writer.writerow([f"Service: {cfg['service']}"])
            writer.writerow([f"Schema: {cfg['schema']}"])
            writer.writerow([f"User: {cfg['user']}"])
            
        logging.info(f"Generated sample CSV file: {output_csv}")
        return True
    except Exception as e:
        logging.error(f"Error creating sample CSV: {str(e)}")
        return False

def sql_to_csv(config_file, query_file, output_csv, execution_timestamp=None):
    """Execute SQL and export to CSV."""
    logging.info("Starting SQL to CSV process")
    try:
        # Check query file exists
        if not os.path.exists(query_file):
            logging.error(f"Query file '{query_file}' not found")
            return False

        cfg = load_config(config_file)
        with open(query_file, 'r', encoding='utf-8') as f:
            query = f.read()
        query = query.replace('<EM_schema>', cfg['schema'])
        
        # Execute appropriate database query
        if cfg.get('db_type', '').upper() == 'ORACLE':
            # Since Oracle connection isn't working, create a dummy CSV
            logging.warning("Oracle direct connection unavailable. Creating sample CSV instead.")
            print("Oracle connection unavailable. Creating a template CSV file instead.")
            print("To get actual data, please run the query in SQL Developer manually.")
            result = create_oracle_dummy_csv(query, output_csv, cfg)
            
            if result:
                # Save the query to a .sql file for convenience
                sql_output = output_csv.replace('.csv', '.sql')
                with open(sql_output, 'w', encoding='utf-8') as sql_file:
                    sql_file.write(query)
                print(f"Query saved to {sql_output} for manual execution")
                
            return result
        else:
            # Regular SQL Server handling
            conn = connect_sql_server(cfg)
            cursor = conn.cursor()
            cursor.execute(query)
            
            columns = [column[0] for column in cursor.description]
            with open(output_csv, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(columns)
                for row in cursor:
                    writer.writerow(row)
            
            cursor.close()
            conn.close()
            logging.info(f"SQL Server query results exported to {output_csv}")
            return True
    except Exception as e:
        logging.error(f"Error in SQL to CSV process: {str(e)}")
        return False
