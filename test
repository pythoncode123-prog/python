import csv
import configparser
import logging
from datetime import datetime
import os
import subprocess
import pyodbc  # Keep this for SQL Server connections

def load_config(config_path):
    """Load database configuration from file."""
    config = configparser.ConfigParser()
    config.read(config_path)
    db_config = config['DATABASE']
    return {
        'host': db_config['DBHost'],
        'port': db_config['Port'],
        'service': db_config['ServiceName'],
        'schema': db_config['SchemaName'],
        'user': db_config['Username'],
        'password': db_config['Password'],
        'db_type': db_config.get('DBType', 'SQLSERVER')
    }

def connect_sql_server(cfg):
    """Connect to SQL server using configuration."""
    conn_str = (
        f"DRIVER={{ODBC Driver 17 for SQL Server}};"
        f"SERVER={cfg['host']},{cfg['port']};"
        f"DATABASE={cfg['service']};"
        f"UID={cfg['user']};"
        f"PWD={cfg['password']}"
    )
    return pyodbc.connect(conn_str)

def execute_oracle_query_through_jdbc(cfg, query, output_csv):
    """
    Execute Oracle query using SQL Developer's JDBC capabilities.
    Requires SQL Developer to be installed.
    """
    # Path to SQL Developer executable - update this to match your installation
    sqldeveloper_path = r"C:\path\to\sqldeveloper\sqldeveloper.exe"
    
    # Create a temporary directory
    temp_dir = os.path.join(os.path.expanduser("~"), "oracle_temp")
    os.makedirs(temp_dir, exist_ok=True)
    
    # Create a SQL file with the query
    sql_path = os.path.join(temp_dir, "query.sql")
    with open(sql_path, 'w') as f:
        f.write(f"{query};")
    
    # Create a connection file
    conn_path = os.path.join(temp_dir, "connection.xml")
    with open(conn_path, 'w') as f:
        f.write(f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<connections>
    <connection>
        <name>OracleConnection</name>
        <oracle.host>{cfg['host']}</oracle.host>
        <oracle.port>{cfg['port']}</oracle.port>
        <oracle.serviceName>{cfg['service']}</oracle.serviceName>
        <oracle.userName>{cfg['user']}</oracle.userName>
        <oracle.password>{cfg['password']}</oracle.password>
    </connection>
</connections>''')
    
    # Create a batch script to run SQL Developer in command line mode
    batch_path = os.path.join(temp_dir, "run_query.bat")
    with open(batch_path, 'w') as f:
        f.write(f'''
@echo off
"{sqldeveloper_path}" -nosplash -noregister -connection OracleConnection -sql "{sql_path}" -outcsv "{output_csv}"
echo SQL Developer execution completed with status %ERRORLEVEL%
''')
    
    try:
        # Run the batch file
        logging.info("Executing Oracle query through SQL Developer JDBC")
        process = subprocess.run(batch_path, shell=True, check=True,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Check if output CSV was created
        if os.path.exists(output_csv) and os.path.getsize(output_csv) > 0:
            logging.info(f"Query results exported to {output_csv}")
            # Clean up temp files
            os.remove(sql_path)
            os.remove(conn_path)
            os.remove(batch_path)
            return True
        else:
            logging.error("SQL Developer execution failed to create CSV file")
            logging.error(f"STDOUT: {process.stdout.decode('utf-8')}")
            logging.error(f"STDERR: {process.stderr.decode('utf-8')}")
            return False
    except subprocess.CalledProcessError as e:
        logging.error(f"SQL Developer execution error: {e}")
        logging.error(f"STDOUT: {e.stdout.decode('utf-8')}")
        logging.error(f"STDERR: {e.stderr.decode('utf-8')}")
        return False
    except Exception as e:
        logging.error(f"Error in Oracle SQL execution: {str(e)}")
        return False
    finally:
        # Cleanup temp files
        try:
            if os.path.exists(sql_path):
                os.remove(sql_path)
            if os.path.exists(conn_path):
                os.remove(conn_path)
            if os.path.exists(batch_path):
                os.remove(batch_path)
        except Exception as cleanup_error:
            logging.warning(f"Error cleaning up temporary files: {cleanup_error}")

def sql_to_csv(config_file, query_file, output_csv, execution_timestamp=None):
    """Execute SQL and export to CSV."""
    logging.info("Starting SQL to CSV process")
    try:
        # Check query file exists
        if not os.path.exists(query_file):
            logging.error(f"Query file '{query_file}' not found")
            return False

        cfg = load_config(config_file)
        with open(query_file, 'r', encoding='utf-8') as f:
            query = f.read()
        query = query.replace('<EM_schema>', cfg['schema'])
        
        # Execute appropriate database query
        if cfg.get('db_type', '').upper() == 'ORACLE':
            return execute_oracle_query_through_jdbc(cfg, query, output_csv)
        else:
            conn = connect_sql_server(cfg)
            cursor = conn.cursor()
            cursor.execute(query)
            
            columns = [column[0] for column in cursor.description]
            with open(output_csv, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(columns)
                for row in cursor:
                    writer.writerow(row)
            
            cursor.close()
            conn.close()
            logging.info(f"SQL Server query results exported to {output_csv}")
            return True
    except Exception as e:
        logging.error(f"Error in SQL to CSV process: {str(e)}")
        return False
