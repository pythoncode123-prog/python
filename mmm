import requests
from requests.auth import HTTPBasicAuth
import pandas as pd
import json
import urllib3
import os
from datetime import datetime
import logging
from typing import Tuple, Optional
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('confluence_update.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ConfluenceReporter:
    def __init__(self, config_path: str = "config.json"):
        self.config = self._load_config(config_path)
        self.session = self._create_session()
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
    def _load_config(self, config_path: str) -> dict:
        with open(config_path, 'r') as f:
            config = json.load(f)
        required_keys = ['CONFLUENCE_URL', 'USERNAME', 'API_TOKEN',
                        'SPACE_KEY', 'PAGE_TITLE', 'CSV_FILE']
        if not all(key in config for key in required_keys):
            raise ValueError(f"Missing required configuration keys. Required: {required_keys}")
        return config
        
    def _create_session(self) -> requests.Session:
        session = requests.Session()
        session.auth = HTTPBasicAuth(self.config['USERNAME'], self.config['API_TOKEN'])
        session.headers.update({
            "Content-Type": "application/json",
            "X-Atlassian-Token": "no-check"
        })
        session.verify = False
        return session
    
    def _format_date(self, date_obj):
        """Format date as M/D/YYYY without leading zeros"""
        if isinstance(date_obj, str):
            # If it's already a string, try to convert to datetime first
            try:
                date_obj = pd.to_datetime(date_obj)
            except:
                return date_obj
        
        month = date_obj.month
        day = date_obj.day
        year = date_obj.year
        return f"{month}/{day}/{year}"
        
    def load_and_process_data(self) -> Tuple[pd.DataFrame, pd.DataFrame]:
        df = pd.read_csv(self.config['CSV_FILE'])
        df['DATE'] = pd.to_datetime(df['DATE'], errors='coerce')
        df_grouped = df.groupby('DATE', as_index=False)['TOTAL_JOBS'].sum()
        df_top4 = df_grouped.nlargest(4, 'TOTAL_JOBS')
        df_top4['Base Line'] = 1899206
        df_top4['Variation'] = df_top4['Base Line'] - df_top4['TOTAL_JOBS']
        return df_top4, df
        
    def generate_table_and_chart(self, df: pd.DataFrame) -> str:
        # First, generate the chart (to match the order in the attachment)
        chart_html = """
<h2>4th Peak of Jan:</h2>
<ac:structured-macro ac:name="chart">
    <ac:parameter ac:name="type">bar</ac:parameter>
    <ac:parameter ac:name="orientation">vertical</ac:parameter>
    <ac:parameter ac:name="dataOrientation">horizontal</ac:parameter>
    <ac:parameter ac:name="legend">true</ac:parameter>
    <ac:parameter ac:name="3D">true</ac:parameter>
    <ac:parameter ac:name="colors">#336600,#CC0000</ac:parameter>
    <ac:parameter ac:name="showValues">true</ac:parameter>
    <ac:parameter ac:name="width">800</ac:parameter>
    <ac:parameter ac:name="height">400</ac:parameter>
    <ac:rich-text-body>
        <table>
            <tbody>
                <tr>
                    <th>Date</th>
"""
        
        # Add dates as column headers
        for _, row in df.iterrows():
            chart_html += f"<th>{self._format_date(row['DATE'])}</th>"
        
        chart_html += """
                </tr>
                <tr>
                    <th>Baseline</th>
"""
        
        # Add baseline values
        for _, row in df.iterrows():
            chart_html += f"<td>{int(row['Base Line'])}</td>"
        
        chart_html += """
                </tr>
                <tr>
                    <th>Total Jobs</th>
"""
        
        # Add total jobs values
        for _, row in df.iterrows():
            chart_html += f"<td>{int(row['TOTAL_JOBS'])}</td>"
        
        chart_html += """
                </tr>
            </tbody>
        </table>
    </ac:rich-text-body>
</ac:structured-macro>
"""
        
        # Then, create the table rows
        table_rows = ["<tr><th>Date</th><th>Baseline</th><th>Total Jobs</th><th>Variation</th></tr>"]
        for _, row in df.iterrows():
            table_rows.append(
                f"<tr><td>{self._format_date(row['DATE'])}</td><td>{int(row['Base Line']):,}</td><td>{int(row['TOTAL_JOBS']):,}</td><td>{int(row['Variation']):,}</td></tr>"
            )
        
        table_html = f"""
<table class="wrapped">
    <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
    </colgroup>
    <tbody>{''.join(table_rows)}</tbody>
</table>
"""
        return chart_html + "\n" + table_html

    def generate_region_chart(self, df: pd.DataFrame) -> str:
        if not {'DATE', 'TOTAL_JOBS'}.issubset(df.columns):
            return ""
            
        df['DATE'] = pd.to_datetime(df['DATE'], errors='coerce')
        
        try:
            # Group by date and sum total jobs
            df_summary = df.groupby('DATE', as_index=False)['TOTAL_JOBS'].sum().sort_values('DATE')
            
            # Format dates
            df_summary['Formatted_DATE'] = df_summary['DATE'].apply(self._format_date)
            
            # Calculate percentages for labels (assuming total sum is needed for percentage)
            total_sum = df_summary['TOTAL_JOBS'].sum()
            df_summary['Percentage'] = (df_summary['TOTAL_JOBS'] / total_sum * 100).round(1)
            
            chart_html = """
<h2>Total Jobs by Date</h2>
<ac:structured-macro ac:name="chart">
    <ac:parameter ac:name="type">bar</ac:parameter>
    <ac:parameter ac:name="orientation">vertical</ac:parameter>
    <ac:parameter ac:name="dataOrientation">vertical</ac:parameter>
    <ac:parameter ac:name="legend">false</ac:parameter>
    <ac:parameter ac:name="3D">true</ac:parameter>
    <ac:parameter ac:name="colors">#336600</ac:parameter>
    <ac:parameter ac:name="showValues">true</ac:parameter>
    <ac:parameter ac:name="width">1000</ac:parameter>
    <ac:parameter ac:name="height">500</ac:parameter>
    <ac:rich-text-body>
        <table>
            <tbody>
                <tr>
                    <th>Date</th>
                    <th>TOTAL_JOBS</th>
                </tr>
"""
            
            # Add data for each date
            for _, row in df_summary.iterrows():
                chart_html += f"""
                <tr>
                    <td>{row['Formatted_DATE']}</td>
                    <td>{int(row['TOTAL_JOBS'])}</td>
                </tr>"""
            
            # Close the chart HTML
            chart_html += """
            </tbody>
        </table>
    </ac:rich-text-body>
</ac:structured-macro>
"""
            # Add the summary table below the chart
            table_html = """
<table class="wrapped">
    <colgroup>
        <col/>
        <col/>
    </colgroup>
    <tbody>
        <tr>
            <th>Date</th>
            <th>Sum of TOTAL_JOBS</th>
        </tr>
"""
            
            # Add the top 5 dates to the table for reference
            for _, row in df_summary.head(5).iterrows():
                table_html += f"""
        <tr>
            <td>{row['Formatted_DATE']}</td>
            <td>{int(row['TOTAL_JOBS']):,}</td>
        </tr>"""
                
            table_html += """
    </tbody>
</table>
"""
            
            return chart_html + "\n" + table_html
                
        except Exception as e:
            logger.error(f"Error generating region chart: {str(e)}")
            return ""

    def generate_daily_summary_table(self, df: pd.DataFrame) -> str:
        df['DATE'] = pd.to_datetime(df['DATE'], errors='coerce')
        df_summary = df.groupby('DATE', as_index=False)['TOTAL_JOBS'].sum()
        
        rows = ["<tr><th>Date</th><th>Sum of TOTAL_JOBS</th></tr>"]
        for _, row in df_summary.iterrows():
            rows.append(f"<tr><td>{self._format_date(row['DATE'])}</td><td>{int(row['TOTAL_JOBS']):,}</td></tr>")
        return f"<h2>Total Jobs Per Day</h2><table class='wrapped'><tbody>{''.join(rows)}</tbody></table>"

    def generate_peaks_variation_table(self, df: pd.DataFrame) -> str:
        baseline = 1899206
        max_range = 2000000
        df['DATE'] = pd.to_datetime(df['DATE'], errors='coerce')
        df_summary = df.groupby('DATE', as_index=False)['TOTAL_JOBS'].sum().sort_values('DATE')
        
        df_summary['Formatted_DATE'] = df_summary['DATE'].apply(self._format_date)
        df_summary['Baseline'] = baseline
        df_summary['Max Range'] = max_range
        df_summary['Variation with Baseline'] = df_summary['Baseline'] - df_summary['TOTAL_JOBS']
        
        # First generate the chart
        chart_html = """
<h2>Variation with Baseline Data:</h2>
<ac:structured-macro ac:name="chart">
    <ac:parameter ac:name="type">line</ac:parameter>
    <ac:parameter ac:name="title">Variation with Baseline Data</ac:parameter>
    <ac:parameter ac:name="width">1000</ac:parameter>
    <ac:parameter ac:name="height">500</ac:parameter>
    <ac:parameter ac:name="dataOrientation">vertical</ac:parameter>
    <ac:parameter ac:name="colors">#336600</ac:parameter>
    <ac:parameter ac:name="showValues">true</ac:parameter>
    <ac:rich-text-body>
        <table>
            <tbody>
                <tr>
                    <th>Date</th>
                    <th>Variation with Baseline</th>
                </tr>
"""
        
        # Add each row of data
        for _, row in df_summary.iterrows():
            chart_html += f"""
                <tr>
                    <td>{row['Formatted_DATE']}</td>
                    <td>{int(row['Variation with Baseline'])}</td>
                </tr>"""
        
        # Close the chart HTML
        chart_html += """
            </tbody>
        </table>
    </ac:rich-text-body>
</ac:structured-macro>
"""
        
        # Then generate the table
        table_html = """
<table class="wrapped">
    <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
    </colgroup>
    <tbody>
        <tr>
            <th>Date</th>
            <th>Peaks</th>
            <th>Variation with Baseline</th>
            <th>Baseline</th>
            <th>Max Range</th>
        </tr>
"""
        
        # Add rows to the table
        for _, row in df_summary.head(5).iterrows():
            table_html += f"""
        <tr>
            <td>{row['Formatted_DATE']}</td>
            <td>{int(row['TOTAL_JOBS']):,}</td>
            <td>{int(row['Variation with Baseline']):,}</td>
            <td>{int(row['Baseline']):,}</td>
            <td>{int(row['Max Range']):,}</td>
        </tr>"""
            
        table_html += """
    </tbody>
</table>
"""
        
        return chart_html + "\n" + table_html

    def generate_market_share_chart(self, df: pd.DataFrame) -> str:
        if not {'Country/Market', 'TaskCount'}.issubset(df.columns):
            return ""
            
        df_market = df.groupby('Country/Market', as_index=False)['TaskCount'].sum().sort_values(by='TaskCount', ascending=False)
        top_markets = df_market.head(10)  # Get top 10 markets for better visualization
        
        chart_html = """
<h2>Task Count by Country/Market</h2>
<ac:structured-macro ac:name="chart">
    <ac:parameter ac:name="type">bar</ac:parameter>
    <ac:parameter ac:name="orientation">vertical</ac:parameter>
    <ac:parameter ac:name="dataOrientation">vertical</ac:parameter>
    <ac:parameter ac:name="legend">false</ac:parameter>
    <ac:parameter ac:name="3D">true</ac:parameter>
    <ac:parameter ac:name="colors">#336600</ac:parameter>
    <ac:parameter ac:name="showValues">true</ac:parameter>
    <ac:parameter ac:name="width">800</ac:parameter>
    <ac:parameter ac:name="height">400</ac:parameter>
    <ac:rich-text-body>
        <table>
            <tbody>
                <tr>
                    <th>Country/Market</th>
                    <th>TaskCount</th>
                </tr>
"""
        
        # Add each row of data
        for _, row in top_markets.iterrows():
            chart_html += f"""
                <tr>
                    <td>{row['Country/Market']}</td>
                    <td>{int(row['TaskCount'])}</td>
                </tr>"""
        
        # Close the chart HTML
        chart_html += """
            </tbody>
        </table>
    </ac:rich-text-body>
</ac:structured-macro>
"""
        return chart_html

    def generate_market_share_table(self, df: pd.DataFrame) -> str:
        if not {'Country/Market', 'TaskCount'}.issubset(df.columns):
            return ""
        df_market = df.groupby('Country/Market', as_index=False)['TaskCount'].sum().sort_values(by='TaskCount', ascending=False)
        rows = ["<tr><th>Country/Market</th><th>Task Count</th></tr>"]
        for _, row in df_market.iterrows():
            rows.append(f"<tr><td>{row['Country/Market']}</td><td>{int(row['TaskCount']):,}</td></tr>")
        return f"<h2>Task Count by Country/Market (Raw Table)</h2><table class='wrapped'><tbody>{''.join(rows)}</tbody></table>"

    def run(self) -> None:
        df_top4, full_df = self.load_and_process_data()
        content = """
<h1>Overall Monthly Task Usage Report</h1>
<p><strong>Last updated:</strong> {now} UTC</p>
<p><strong>Generated by:</strong> {user}</p>
{table_and_chart}
{region_chart}
{daily_table}
{peaks_variation_table}
{market_share_chart}
{market_share_table}
<hr/>
<p><em>Note: This report shows the top 4 dates with highest total jobs compared to baseline.</em></p>
""".format(
            now="2025-05-19 00:28:28",
            user='satish537',
            table_and_chart=self.generate_table_and_chart(df_top4),
            region_chart=self.generate_region_chart(full_df),
            daily_table=self.generate_daily_summary_table(full_df),
            peaks_variation_table=self.generate_peaks_variation_table(full_df),
            market_share_chart=self.generate_market_share_chart(full_df),
            market_share_table=self.generate_market_share_table(full_df),
        )
        page_id, version = self.get_page_info()
        self.create_or_update_page(content, page_id, version)

    def get_page_info(self) -> Tuple[Optional[str], Optional[int]]:
        params = {
            'title': self.config['PAGE_TITLE'],
            'spaceKey': self.config['SPACE_KEY'],
            'expand': 'version'
        }
        response = self.session.get(self.config['CONFLUENCE_URL'], params=params)
        response.raise_for_status()
        data = response.json()
        if data['size'] > 0:
            return data['results'][0]['id'], data['results'][0]['version']['number']
        return None, None

    def create_or_update_page(self, content: str, page_id: Optional[str] = None, version: Optional[int] = None):
        payload = {
            "type": "page",
            "title": self.config['PAGE_TITLE'],
            "space": {"key": self.config['SPACE_KEY']},
            "body": {"storage": {"value": content, "representation": "storage"}}
        }
        if page_id:
            payload["id"] = page_id
            payload["version"] = {"number": version + 1}
            response = self.session.put(f"{self.config['CONFLUENCE_URL']}/{page_id}", json=payload)
        else:
            response = self.session.post(self.config['CONFLUENCE_URL'], json=payload)
        response.raise_for_status()
        logger.info(f"Page [{self.config['PAGE_TITLE']}] {'updated' if page_id else 'created'} successfully")

def main():
    try:
        reporter = ConfluenceReporter()
        reporter.run()
    except Exception as e:
        logger.error(f"Fatal error: {str(e)}")
        raise

if __name__ == "__main__":
    main()
